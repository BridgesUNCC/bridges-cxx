#ifndef KD_TREE_ELEMENT_H
#define KD_TREE_ELEMENT_H

#include <sstream>

#include "BSTElement.h" //string, sstream, using std

#include <JSONutil.h>

namespace bridges {
	namespace datastructure {
		/**
		 * @brief This class can be used to create K-d Tree  elements, derived
		 *  from BSTElement. K-D trees can be thought of as the spatial equivalent
		 *  binary search trees and operate on multiple dimensions (2D and 3D are
		 *	most common). These trees serve as a representation of the underlying
		 *	geometrically defined spaces. Specialized versions of these trees
		 *	include quadtrees and octrees, which subdivide into equal sized quadrants
		 *	octants at each level, respectively.
		 *
		 *	This class extends the BSTElement class by adding a dimension property.
		 *	It also includes a thickness property for displaying the partitioning
		 *	lines generated by the convex decomposition.
		 *
		 *	convenient to generate visual representation
		 *	to allow for use in a binary search tree implementation.
		 *
		 * @sa There is a tutorial about K-d Trees  :
		 * https://bridgesuncc.github.io/tutorials/KdTree.html
		 *
		 *      @param K that is the search key type - this is usually a number, integer
		 *			or float
		 *      @param E the application data type
		 *
		 * @author Kalpathi Subramanian
		 * @date 6/18/15, 7/17/16, 12/28/20
		 *
		 **/
		template <typename K, typename E>
		class KdTreeElement : public BSTElement<K, E> {
			private:
				int dimension = 0;		// dimension, in the range [0..k-1]
				float thickness = 0;		// thickness of partitioning lines
			public:
				/**
				 * Constructs a KdTreeElement with the provided value, label, key,
				 * left and right KdTree elements.  The defaults will be used if
				 * not provided.
				 *
				 * @param k The key for ordering
				 * @param dim number of dimension to be partitioned
				 * @param th thickness of the line showing the partition
				 * @param l The left KdTree Element
				 * @param r The right KdTree Element
				 * @param val The data to hold
				 * @param lab The label to show
				 */
				KdTreeElement(const K& k, int dim, int th,
					const KdTreeElement* l, const KdTreeElement* r,
					const E& val = E(), const string& lab = string())
					: BSTElement<K, E>(k, l, r, val, lab),
					  thickness(th), dimension(dim) {
				}
				/**
				 * Constructs a KdTreeElement with the provided value, label, key,
				 * setting the left and right KdTreeElement to NULL.
				 * The defaults will be used if not provided.
				 *
				 * @param k The key for ordering
				 * @param dim number of dimensions being partitioned
				 * @param th thickness of the line showing the partition
				 * @param val The data to hold
				 * @param lab The label to show
				 */
				KdTreeElement(const K& k, int dim, int th = 0,
					const E& val = E(), const string& lab = string())
					: BSTElement<K, E>(k, nullptr, nullptr, val, lab),
					  dimension(dim), thickness(th) {
				}
				/** @return the data structure type */
				virtual const string getDStype() const override {
					return "KdTree";
				}
				/**
				 *  @brief Get Dimension of the partition
				 *	@return return the partitioning of this node
				 */
				int getDimension() const {
					return dimension;
				}
				/**
				 *@brief  Set partitioning dimension to "dim"
				 *
				 * @param dim The partitioning dimension of this Kd tree element
				 */
				void setDimension(const int& dim) {
					dimension = dim;
				}
				/**
				 *  @brief Get thickness of the partition
				 *	@return return the partitioner thickness
				 */
				float getThickness() const {
					return thickness;
				}
				/**
				 * @brief Set partitioning dimension to "dim"
				 *
				 * @param th The thickness of the partitioner to set
				 */
				void setThickness(const float& th) {
					thickness = th;
				}
				/**
				 *  @brief Get partitioner value
				 *	@return return the partitioner value
				 */
				K getPartitioner() const {
					return this->getKey();
				}
				/**
				 * @brief Set partitioning dimension to "dim"
				 *
				 * @param p The partitioning dimension value of this Kd tree element
				 */
				void setPartitioner(const K& p) {
					this->setKey();
				}
				/**
				 *	@brief Get left child
				 * 	@return The left child
				 */
				virtual KdTreeElement* getLeft() override {
					return static_cast<KdTreeElement*>(BSTElement<K, E>::getLeft());
				}
				/**
				 *	@brief Get left child - constant version
				 *
				 * @return The left child
				 */
				virtual const KdTreeElement* getLeft() const override {
					return static_cast<const KdTreeElement*>(BSTElement<K, E>::getLeft());
				}
				/**
				 * @brief Sets left child to "l"
				 *
				 * @param l The left child
				 */
				void setLeft(KdTreeElement* l) {
					BSTElement<K, E>::setLeft(l);
				}
				/**
				 *	@brief Get right child
				 *	@return The right child
				 */
				virtual KdTreeElement* getRight() override {
					return static_cast<KdTreeElement*>(BSTElement<K, E>::getRight());
				}
				/**
				 * @brief Get right child - Constant version
				 *
				 * @return The right child
				 */
				virtual const KdTreeElement* getRight() const override {
					return static_cast<const KdTreeElement*>(BSTElement<K, E>::getRight());
				}
				/**
				 * @brief Sets right child to "r"
				 *
				 * @param r The right BSTElement
				 */
				void setRight(KdTreeElement* r) {
					BSTElement<K, E>::setRight(r);
				}
			protected:
				/**
				 * @brief get kd tree element representation as JSON string
				 */
				virtual const string getElementRepresentation() const override {
					using bridges::JSONUtil::JSONencode;
					string json =  BSTElement<K, E>::getElementRepresentation();
					stringstream dim_str, thck_str;
					dim_str << dimension;
					thck_str << thickness;
					return json.insert(
							json.size() - 1,
							COMMA + QUOTE + "dimension" + QUOTE + COLON +
							JSONencode(dim_str.str()) +
							COMMA + QUOTE + "thickness" + QUOTE + COLON +
							JSONencode(thck_str.str())
						);
				}
		}; //end of KdtreeElement class
	}
}//end of bridges namespace
#endif
